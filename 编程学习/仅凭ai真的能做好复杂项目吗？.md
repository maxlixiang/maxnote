仅凭ai真的能做好复杂项目吗？

我用亲身经历回答这个问题。

我在 nginx 团队工作。前段时间做了一个实验：让 AI 从零写一个 C 项目——用 C + QuickJS 实现的可编程 HTTP 压测工具，涉及 epoll 事件驱动、多线程、TLS 加密、红黑树定时器、嵌入式 JS 引擎。然后在不手写任何代码的前提下，纯粹通过指导 AI 来重构它的架构。

整个过程写了十篇文章，有完整的代码变更记录。结论不是”能”或”不能”，是比这复杂得多的东西。

## AI 写完，我惊讶了两次

第一次惊讶：**它真的能跑。** 

两千行 C 代码，一天写完。能编译，能跑，测试通过。命名准确，前缀一致——十三个源文件上百个函数，`js_` 前缀没有一处遗漏。在 C 这种没有命名空间的语言里，这个纪律性比很多人类项目都好。

性能也是真的。纯 C 的 epoll 事件循环、非阻塞 I/O、多线程各跑各的实例，实测 140K+ QPS，跟 wrk 同一量级。这不是玩具。

第二次惊讶：**看完整体之后，说不清哪里不对，但就是不舒服。** 

每个函数独立看都没问题。但文件之间的关系、模块之间的边界、依赖的方向——没有整体设计。所有东西都能跑，但你感觉它们不是被”设计”在一起的，是被”堆”在一起的。

**AI 写的代码像一栋没有图纸的房子——每面墙砌得都不错，但你走进去会迷路。** 

## “能跑”和”做好”是两回事

如果”做好”的标准是”功能能跑、测试通过”——AI 做到了。

但如果”做好”包括”代码改得动、加功能不用理解半个系统、bug 真的能被发现”——AI 没做到。

我后来对两个版本做了逐维度评分。AI 自己写的版本 59 分，经过我指导重构的版本 85 分（满分 105）。

涨的不是功能。功能完整度 8/10，重构前后没变。可读性 8/10，也没变。AI 本来就做得好的维度，不需要人。

**涨的全是架构维度：异步设计从 7 涨到 14，抽象质量从 5 涨到 9，可维护性从 4 涨到 7，代码组织从 5 涨到 8。** 

26 分的差距，每一分都是架构。

## 最危险的事：一切看起来正常

整个过程中最让我震动的不是架构问题，是下面这件事。

我修完 fetch 的并发 bug 之后，测试全过。继续 review 代码，发现 bench 模式的 worker 线程里根本跑不起 fetch。**每一次请求都失败了。** 

但测试报告：**16576 次请求，0 错误，通过。** 

原因：代码把每次调用无条件计入”成功”，测试只看这个数字。

**AI 写的代码不检查错误，AI 写的测试不验证错误。它们有一致的盲区——完美地互相配合，制造了”一切正常”的假象。** 

这不是偶然。实现和测试是同一个模型生成的，盲区是一致的。你从任何一边都看不出问题。只有人从外部 review，才能打破这个闭环。

想象一下：如果我没 review，这个项目就带着”16576 次全失败”的 bug 上线了，而所有测试都是绿的。

**这就是”仅凭 AI”最大的风险——不是代码写不出来，是出了问题你不知道。** 

## 方向对了，AI 的执行力是惊人的

但故事还有另一面。

重构过程中我发现，一旦人给出准确的方向，AI 的执行力远超人类。

我说了一句话：”每个线程有且只有一个 epoll。”

就这一句。AI 立刻知道该怎么做了——用 thread-local 存储，重写所有 epoll 接口，去掉每个调用点的 fd 参数。涉及十几处分散在不同文件的修改，一次做完，编译零警告。

我说”这个字段不该在 conn 里，它属于一个叫 http_peer 的新概念”——AI 创建新结构体，搬移字段，更新所有引用，6 个文件 20 多处改动，没有一处遗漏。

我给 fetch 一个新的架构方向——全局事件循环 + pending Promise——AI 一次改对了，9 个文件，fetch 的并发性能从 905ms 变成 302ms。

人工做这种跨文件的改动，20 处修改总有可能漏一处。AI 不会。

**但每一次的前提都是：我给了它一个准确的判断。** 

没有那句话，AI 在原地打转——它会给你列出几种方案，但不会替你拍板。有了那句话，它比任何人类工程师都执行得更快更可靠。

## 那到底能不能”仅凭 AI”？

说说我的结论。

**能，如果你的标准是”能跑”。**  AI 确实能在一天之内写出两千行 C 系统级代码，涉及 epoll、TLS、多线程、嵌入式 JS 引擎，编译通过，测试通过，性能达标。这在几年前不可想象。

**不能，如果你的标准是”做好”。**  AI 写的代码能跑但改不动，测试能过但验不对，架构能用但不能长期维护。59 分和 85 分的差距，就是”能跑”和”做好”的距离。

但更准确的回答是：**“仅凭 AI”本身就是个伪命题。** 

因为你没法把人完全拿走。AI 不会主动发现架构问题，不会主动打破代码和测试的共同盲区，不会在”一切看起来正常”的时候说”这里不对”。它有知识，但没有判断。它能列出所有设计模式，但面对一团纠缠的代码，它不会说”先改这个，这个解决了那个才能动”。

真正有效的方式是：**人定方向，AI 执行。** 

我发现问题 → 想清楚方向 → 告诉 AI → review 结果 → 纠正细节。这个循环贯穿了整个项目。十次重构，每次都是这个模式。没有一次是 AI 自己发起的。

## 那人的作用到底是什么？

这个项目让我想清楚了一件事：**AI 时代，人的价值不在写代码，在做判断。** 

判断什么？

- **判断哪里不对。**  AI 的 fetch 是伪异步，每个调用创建独立的 epoll 实例——这不是某一行代码写错了，是整个 I/O 模型就不对。AI 不知道这是问题。我知道，因为在 nginx 团队做了多年事件驱动架构。
- **判断该往哪走。**  “全局事件循环 + pending Promise”——这一句话定义了整个异步架构的方向。AI 拿到这句话，9 个文件一次改对。但这句话本身需要经验。
- **判断什么时候该怀疑。**  测试全绿，功能能跑——这时候绝大多数人会觉得”可以了”。但我继续 review，发现了 16576 次全失败的 bug。不是因为我更聪明，是因为经验告诉我”看起来太顺利的时候往往有问题”。

**你的一个判断，AI 能帮你落到几十个文件的每一行代码上。判断越准确，杠杆越大。** 

反过来说：如果判断是错的，AI 会非常高效地把错误铺满整个项目。

## 一个反直觉的结论

很多人觉得 AI 能写代码了，架构就不重要了。

恰恰相反。

**AI 让写代码变得越容易，架构就变得越重要。** 

为什么？因为写代码的成本趋近于零，但管理复杂度的成本没有变。AI 写代码的速度远快于人类，如果没有架构来管理复杂度，AI 写得越快，系统就越快变成一团无法维护的意大利面。

在 jsbench 上我亲眼看到了这个过程。AI 一天写出两千行能跑的代码，但复杂度失控了：连接层嵌着 HTTP 解析器，fetch 是伪异步，定时器三套实现，请求类型拆成两个。功能都能跑，但代码改不动。

**没有架构的 AI 代码，是一台高效的技术债生成器。** 

有架构的 AI 代码，是你的整个团队。

## 实用建议

如果你正在用 AI 做项目，几条经验：

**1. AI 写完之后，先看架构维度。**  功能能不能跑、命名好不好——这些 AI 通常做得不错。把注意力放在模块之间的依赖方向、该有的概念有没有被表达成类型、复杂度有没有被隔离。这些是 AI 最容易丢分的地方。

**2. 给约束，不给方案。**  不要告诉 AI”把这个函数拆成三个”。告诉它”这一层不应该知道上面那一层的存在”。约束定义方向，AI 自己能推导出所有具体改动。一句准确的约束，AI 能落到几十个文件上。

**3. Review 测试本身。**  AI 写的测试和代码有一致的盲区。确保测试验证的是真正的结果，不只是”有输出”。

**4. 用最强的模型。**  架构级的改动需要理解上下文、保持跨文件一致。模型越强，做得越好。这个差别非常大。

**5. 多实践，多看专业的代码，多跟专业的人交流。**  判断力不是凭空来的。我的架构判断很大程度上来自阅读 nginx、njs 这些项目的源码，和在团队里跟顶级工程师一起工作磨出来的。AI 能放大能力，但能力本身的来源是实践、代码和人。

## 所以，回到这个问题

仅凭 AI 真的能做好复杂项目吗？

我的回答：**AI 能写出复杂项目的代码，但写不出复杂项目的架构。**  代码是砖墙，架构是图纸。AI 砌墙又快又好，但图纸还得人画。

好消息是，你不需要自己砌墙了。你只需要画好图纸，AI 能帮你把每一面墙砌到位。

**未来的程序员不是写代码的人，是做判断的人。** 


---


我是nginx核心成员，主页有AI重构真实项目的完整案例。关注我，一起用AI放大个人能力。



---

## 评论

共 106 条评论，已存 17 条

### jmicoding

我认为 ai编程很容易写出来看起来正确但实际上埋隐蔽坑代码，这是是把工程化风险右移到测试阶段，测试需要设计丰富的测试用例才能找出来其中的bug。

2026-02-17 江西 9 赞

> #### 半卷的尾巴
> 
> 的确，但是如果用它把整个项目跑完的话，bug已经埋的非常深了
> 
> 2026-02-17 湖北 0 赞

### 勤川

先让AI做架构设计，写文档，然后让它实现

2026-02-15 四川 11 赞

### dbsx

一定要有人先做好架构设计，这样的话我们才知道判断对不对，而且我现在觉得写代码的时候，最有意思的部分不是真的让AI去写，而是在跟他探讨整个架构的过程中。而且AI他还会从互联网上去对比不同的这种思路。我甚至可以一个非常小白的菜鸟的方式去问他，为什么这里用这种架构

2026-02-16 上海 6 赞

> #### NGINX洪志道
> 
> 是的。我在写第二个栏目，就是先设计再写代码，是很有必要的。差别类似让AI少走了一些弯路，但是即使代码写出来了，架构还是得人和AI去不断改进。
> 
> 2026-02-16 福建 4 赞

### shvc

再给AI点时间，一年后再试试[大笑]

2026-02-16 上海 6 赞

> #### NGINX洪志道
> 
> 很期待哈，AI出来后我就开始用了，每次进步都非常明显。
> 
> 2026-02-16 福建 3 赞
> 
> #### 出收集者的格温
> 
> 这是最恐怖的，没人知道一年后ai会进步到那一步
> 
> 2026-02-18 湖南 0 赞

### 张东杰

架构又往往是最值钱的东西，应该写一本人人都是架构师[大笑]

2026-02-20 06:00:00 湖南 1 赞

### NGINX洪志道

我使用的是claude code + opus 4.6。

2026-02-16 福建 1 赞

> #### 象道
> 
> sonnet编程，opus是万事通[doge]
> 
> 2026-02-16 加拿大 0 赞

### 严懿宸

不了解相关背景，想咨询下，关于这段：“AI 的 fetch 是伪异步，每个调用创建独立的 epoll 实例——这不是某一行代码写错了，是整个 I/O 模型就不对。AI 不知道这是问题。我知道，因为在 nginx 团队做了多年事件驱动架构”，这是一个AI缺少的知识吗，还是说是AI在糊代码的过程中并未认识到这个问题？

2026-02-15 上海 2 赞

### 小熊

我不会编程只认识基础语法，什么技术都不懂，我只会给ai说我要个什么页面ui有哪些按钮，有什么功能，一个星期写了个软件直接给我提效十倍，我觉得够用了，对我这种小白太友好了

2026-02-16 甘肃 2 赞

> #### 勃尔
> 
> 前端和python是现在ai写得最好的
> 
> 2026-02-16 广西 4 赞

### 王东岳

但是从另一个角度讲，你说的这些“跨十几个文件的修改”在设计良好的代码里根本不会发生。包括threadlocal，其实更好的办法肯定是避免使用这种类似全局变量的东西，而是开一堆线程每个有自己的context

2026-02-16 天津 0 赞

> #### NGINX洪志道
> 
> 第一个版本就是让AI全部写，没有人的干预，所以设计上比较粗糙。让它改核心部分，这种改动量就正常。
> 
> 2026-02-16 福建 1 赞

### wanw

就是这样，有了ai，程序员变成决策者而不是执行者了。

2026-02-16 广西 1 赞
