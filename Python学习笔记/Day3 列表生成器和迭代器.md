
## 列表生成器
list(range(10))
```python

L = [x*x for x in range(1,11)]

print(L)
```


## 迭代器

提到迭代器`Iterator`，就要想到它是惰性的，只能用`next()`调用

凡是可作用于`for`循环的对象都是`Iterable`类型；

凡是可作用于`next()`函数的对象都是`Iterator`类型，它们表示一个惰性计算的序列；

集合数据类型如`list`、`dict`、`str`等是`Iterable`但不是`Iterator`，不过可以通过`iter()`函数获得一个`Iterator`对象。

Python的`for`循环本质上就是通过不断调用`next()`函数实现的




### 一、核心基础：生成器是什么？
首先要理解生成器的本质：
生成器是Python中一种**惰性迭代器**（lazy iterator），它不会一次性生成并存储所有数据，而是在迭代过程中**按需生成**数据，用完即丢，极大节省内存。
- 类比理解：列表是“一次性把所有零食摆出来”，生成器是“吃一个拆一个，拆完就吃，不囤货”。
- 核心特点：只能迭代一次（数据生成后无法回溯）、惰性计算（不调用不生成）。

### 二、必须掌握的生成器创建方式
生成器有两种核心创建方式，这是基础中的基础：

#### 1. 生成器表达式（最简方式）
语法和列表生成式几乎一致，只是把`[]`换成`()`，但行为完全不同：

```python
# 列表生成式：一次性生成所有数据，占用内存
lst = [x*2 for x in range(1000000)]  # 会立即生成百万个元素，占大量内存

# 生成器表达式：仅创建生成器对象，不生成数据
gen = (x*2 for x in range(1000000))  # 几乎不占内存，只有迭代时才计算
```

**关键区别**：
- 列表生成式返回`list`对象，可直接索引（如`lst[0]`）；
- 生成器表达式返回`generator`对象，不可索引，只能通过`next()`或`for`循环迭代。

#### 2. 生成器函数（带`yield`的函数）
这是生成器最灵活的创建方式，核心是用`yield`替代`return`：

```python
# 生成器函数：生成1到n的整数
def my_generator(n):
    for i in range(1, n+1):
        # 暂停执行，返回i；下次迭代时从这里继续
        yield i  

# 创建生成器对象（函数调用不执行代码，仅返回生成器）
gen = my_generator(3)

# 迭代生成器（触发代码执行）
print(next(gen))  # 输出1（执行到第一个yield，暂停）
print(next(gen))  # 输出2（从上次暂停处继续，执行到第二个yield）
print(next(gen))  # 输出3（执行到第三个yield）
print(next(gen))  # 抛出StopIteration异常（迭代结束）
```

**核心理解**：
- 调用生成器函数不会立即执行函数体，只会返回一个生成器对象；
- 每次调用`next()`或遍历生成器时，函数执行到`yield`处暂停，返回`yield`后的值；
- 再次迭代时，从暂停的位置继续执行，直到遇到下一个`yield`或函数结束。

### 三、生成器的核心方法与特性
#### 1. 基本迭代方式
除了`next()`，更常用的是`for`循环（自动捕获`StopIteration`异常，无需手动处理）：

```python
gen = my_generator(3)
for num in gen:
    print(num)  # 依次输出1、2、3（循环结束后生成器耗尽）
```

#### 2. `send()`方法（双向通信）
生成器不仅能返回数据，还能接收外部传入的数据：

```python
def counter():
    count = 0
    while True:
        # 接收外部传入的值，赋值给n；首次send需传None
        n = yield count  
        if n is not None:
            count = n  # 重置计数器
        count += 1

gen = counter()
print(next(gen))  # 输出0（执行到yield，返回count=0，暂停）
print(gen.send(5))  # 传入5，n=5 → count=5 → count+=1=6 → 输出6
print(next(gen))  # count+=1=7 → 输出7
```

#### 3. `close()`方法（手动终止）
可主动关闭生成器，后续迭代会直接抛出`StopIteration`：

```python
gen = my_generator(3)
gen.close()
next(gen)  # 抛出StopIteration异常
```

### 四、生成器的使用场景（为什么要用？）
这是掌握生成器的关键——知道什么时候该用：
1. **处理大数据集**：比如读取超大文件、生成百万级数据，用生成器避免一次性加载所有数据到内存（解决内存溢出问题）；
   
```python
   # 逐行读取超大文件（生成器版）
   def read_large_file(file_path):
       with open(file_path, 'r', encoding='utf-8') as f:
           for line in f:  # 文件对象本身也是迭代器，逐行读取
               yield line.strip()

   # 遍历文件内容，每次仅加载一行到内存
   for line in read_large_file('big_file.txt'):
       print(line)
   ```

2. **无限序列生成**：比如生成无限的自增数字、斐波那契数列（列表无法存储无限数据，生成器可按需生成）；
   
```python
   # 生成无限斐波那契数列
   def fibonacci():
       a, b = 0, 1
       while True:
           yield b
           a, b = b, a + b

   gen = fibonacci()
   # 取前5个斐波那契数
   for _ in range(5):
       print(next(gen))  # 输出1、1、2、3、5
   ```

3. **简化迭代逻辑**：替代复杂的类式迭代器（无需实现`__iter__`和`__next__`方法）；
4. **协程基础**：生成器是Python早期协程的实现基础（如`asyncio`的底层原理）。

### 五、生成器与列表/迭代器的核心对比
| 特性                | 列表              | 生成器            |
|---------------------|-------------------|-------------------|
| 内存占用            | 一次性占用全部内存 | 几乎不占内存（按需生成） |
| 可索引性            | 支持（如`lst[0]`） | 不支持            |
| 迭代次数            | 可多次迭代        | 只能迭代一次      |
| 创建时机            | 立即生成所有数据   | 惰性生成（迭代时生成） |
| 适用场景            | 小数据集、需反复使用 | 大数据集、一次性遍历 |

### 六、常见易错点
1. **生成器耗尽后无法复用**：迭代一次后，生成器就“空了”，再次迭代不会有数据返回；
   
```python
   gen = (x for x in [1,2,3])
   list(gen)  # [1,2,3]（生成器耗尽）
   list(gen)  # []（无数据）
   ```

2. **混淆生成器表达式和元组**：`(x for x in range(3))`是生成器，不是元组，要创建元组需用`tuple(x for x in range(3))`；
3. **`yield`不能在普通函数中使用**：只有定义为生成器函数（带`yield`），调用才会返回生成器对象。

### 总结
1. 生成器的核心是**惰性迭代**，按需生成数据，解决大数据场景的内存问题，这是它和列表最本质的区别；
2. 掌握两种创建方式：生成器表达式（`()`）和生成器函数（`yield`关键字），其中`yield`是生成器函数的核心，能暂停/恢复函数执行；
3. 重点掌握生成器的使用场景：处理超大文件、生成无限序列、简化迭代逻辑，这也是实际开发中生成器最有价值的地方。

---
